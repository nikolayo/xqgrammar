==Full Text LL(`*`) Problems==

As noted on project home page and in code - 8 tokens related to Full Text cause grammar issues if their use as NCName is allowed : 'ftand', 'ftcontains', 'ftor', 'insensitive', 'sensitive', 'stemming', 'thesaurus', 'wildcards'. Five out of these seem  easy to handle with the help of syntactic predicates as follows:

`ftPrimaryWithOptions : ftPrimary ((ftMatchOptions)=>ftMatchOptions)? ftWeight? ;`

`ftMatchOptions : ((ftMatchOption)=>ftMatchOption)+ ;`

or somewhat more efficiently overall - just:

`ftPrimaryWithOptions : ftPrimary ((ftMatchOption)=>ftMatchOption)* ftWeight? ;`

This leaves 3 offending tokens : 'ftand', 'ftcontains' and 'ftor' which cause non LL(`*`) issues with the rule for `stepExpr`. The root cause for these is apparently the "naked" curly bracket syntax in the rule for `ftWordsValue` :

`ftWordsValue : literal | '{' expr '}' ;`

If it is replaced by something like :

`ftWordsValue : literal | FT_WORDS_VALUE '{' expr '}' ;`

then problems with `stepExpr` disappear (but of course the tests from the suite do not pass). I have not discovered yet how exactly this construct damages `stepExpr`. So far I just know by previous experience that given the XQuery syntax with essentially no reserved words and with heavy (over)use of curly brackets it is very difficult to introduce new curly bracket constructs without causing problems. For example, here is a non LL(`*`) decision I discovered in earlier draft of Scripting where blocks where "naked" :

`if(condition) then element else {...}`

versus

`if(condition) then element else {...} else other`


One way or another - remaining 3 token issues will be resolved but at the end of the day there will also be the question : is the ability to use 8 tokens as NCName's worth the cost of additional backtracking? So far I am more inclined to answer "no" than "yes" but I am certainly inclined too to listen to community feedback on the matter. There is in theory also the option of left factoring but at this time left factoring all the way up from `ftWordsValue` to `pathExpr` does not seem as a realistic option.

P.S.:

One interesting question is what does the following statement mean in Full Text?

`element ftcontains {'whatever'}`

Without full text this is clearly computed element constructor for element with name `ftcontains`. With full text though it could also be `ftContainsExpr` with first operand `element` (which is a valid relative path expression and hence - `rangeExpr`), operator `ftcontains` and second operand `{'whatever'}` which is valid `ftWordsValue` and hence - valid `ftSelection`. Could it be that the grammar is ambiguous? W3C working group should know better than this in a candidate recommendation, so it is more likely my mistake but what exactly? Similar constucts seem possible with `ftand` and `ftor` as well as with other computed constructors.